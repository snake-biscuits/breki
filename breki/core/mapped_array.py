"""Base classes for defining .bsp lump structs"""
from __future__ import annotations
import enum
import struct
from typing import Any, Dict, Iterable, List, Union

from . import bitfield
from . import common


ArraysDict = Dict[str, Union[int, List[str], Dict[str, Any]]]  # recursive
# ^ {"a": 2, "b": [*"xyz"], "c": {"u": [*"xy"], "v": [*"xy"]}}
# TODO: {int: Mapping} mappings (list of MappedArray)
# -- e.g. {"triangle": {3: Vertex}}
# -- int dict keys could get dicey, but this is already for rare edge cases
AttrMap = Union[List[str], ArraysDict]
# ^ ["a", "b", "c"]
# NOTE: BitFieldMapping & ClassesDict allow "attr.sub" keys
# -- this is because they index structures defined by ArraysDict / AttrMap


# for Struct: mapping_length({s: Struct._arrays.get(s, None) for s in Struct.__slots__})
def mapping_length(mapping: AttrMap) -> int:  # MappedArray._mapping focused
    """counts length of tuple required for mapping"""
    if isinstance(mapping, list):
        return len(mapping)
    length = 0
    for child_mapping in mapping.values():
        if isinstance(child_mapping, list):  # assumes list of single attrs
            length += len(child_mapping)
        elif isinstance(child_mapping, int):
            length += child_mapping
        elif isinstance(child_mapping, dict):
            length += mapping_length(child_mapping)
        elif child_mapping is None:
            length += 1
        else:
            raise RuntimeError(f"Unexpected Mapping! ({mapping}, {child_mapping})")
    return length


class MappedArray:
    """Maps a given iterable to a series of names, can even be a nested mapping"""
    _mapping: AttrMap = list()
    _format: str = ""  # struct format string
    _attr_formats: Dict[str, str] = dict()  # generated by __init__
    _bitfields: bitfield.BitFieldsDict = dict()
    _classes: common.ClassesDict = dict()

    def __init__(self, *args, _mapping=None, _format=None, _bitfields=None, _classes=None, **kwargs):
        self._mapping = self._mapping if _mapping is None else _mapping
        self._format = self._format if _format is None else _format
        self._bitfields = self._bitfields if _bitfields is None else _bitfields
        self._classes = self._classes if _classes is None else _classes
        assert len(args) <= len(self._mapping), "Too many arguments! Should match top level attributes!"
        invalid_kwargs = set(kwargs).difference(set(self._mapping))
        # TODO: could branch here and check for subattr kwargs
        # subattr_values = {a: dict_subgroup(kwargs, a) for a in {k.partition(".")[0] for k in invalid_kwargs}}
        # invalid_kwargs = set(subattr_values).difference(set(self.__slots__))
        # TODO: check each subgroup for invalid values targetting _arrays, also recurse down into BitFields
        assert len(invalid_kwargs) == 0, f"Invalid kwargs: {invalid_kwargs}"
        if len(args) == len(self._mapping):  # all values are defined
            default_values = dict()
        # NOTE: could also skip generating defaults if arg + kwargs defines the whole struct
        # -- however that's probably more work to detect than could be saved so \_(0.0)_/
        else:
            # NOTE: _defaults is a classmethod, so we MUST override
            default_values = self._defaults(_mapping=self._mapping, _format=self._format)
        default_values.update(dict(zip(self._mapping, args)))
        default_values.update(kwargs)
        # TODO: set subattr_values
        types = common.split_format(self._format)
        types_index = 0
        if isinstance(_mapping, list):
            self._attr_formats = dict(zip(_mapping, types))
            for attr, value in default_values.items():
                setattr(self, attr, value)
            return
        self._attr_formats = dict()  # must be unique
        for attr, value in default_values.items():
            # child contructor metadata
            if isinstance(self._mapping, dict):
                sub_mapping = self._mapping[attr]
            else:
                sub_mapping = None
            length = mapping_length({None: sub_mapping})
            self._attr_formats[attr] = "".join(types[types_index:types_index + length])
            types_index += length
            sub_classes = common.subgroup(self._classes, attr)
            sub_bitfields = common.subgroup(self._bitfields, attr)
            if isinstance(value, MappedArray):
                assert isinstance(sub_mapping, (list, dict)), f"Invalid sub_mapping for {attr}: {sub_mapping}"
                assert value._mapping == sub_mapping
                value._classes = sub_classes
                value._bitfields = sub_bitfields
                setattr(self, attr, value)
            # TODO: List[MappedArray]
            elif isinstance(sub_mapping, int):
                assert len(value) == sub_mapping
                setattr(self, attr, value)
            elif isinstance(sub_mapping, (list, dict)):  # create MappedArray
                sub_format = self._attr_formats[attr]
                sub_kwargs = dict(_mapping=sub_mapping, _format=sub_format, _classes=sub_classes, _bitfields=sub_bitfields)
                setattr(self, attr, MappedArray.from_tuple(value, **sub_kwargs))
            elif sub_mapping is None:
                setattr(self, attr, value)
            else:
                raise RuntimeError(f"{self.__class__.__name__} has bad _mapping")

    def __eq__(self, other: Iterable) -> bool:
        return all([(a == b) for a, b in zip(self, other)])

    # TODO: __getattr__ swizzle detection (if and only if mapping is a list of single chars)

    def __getitem__(self, index: str) -> Any:
        return getattr(self, self._mapping[index])

    def __hash__(self):
        return hash(tuple(self.as_tuple()))

    def __iter__(self) -> Iterable:
        return iter([getattr(self, attr) for attr in self._mapping])

    def __len__(self) -> int:
        return len(self._mapping)

    def __repr__(self) -> str:
        attrs = [f"{attr}: {value!r}" for attr, value in zip(self._mapping, self)]
        return f"<{self.__class__.__name__} ({', '.join(attrs)})>"

    def __setattr__(self, attr, value):
        # NOTE: private variables must pass through untouched!
        # NOTE: bitfield & class should be mutually exclusive, so order doesn't matter
        value = common.school(self, attr, value)
        # TODO: enforce BitField spec (_fields, _format, _classes)
        if attr in self._bitfields and not isinstance(value, bitfield.BitField):
            child_format = self._attr_formats[attr]
            value = bitfield.BitField.from_int(
                value,
                _fields=self._bitfields[attr],
                _format=child_format,
                _classes=common.subgroup(self._classes, attr))
        # TODO: enforce child MappedArray spec
        super().__setattr__(attr, value)

    @classmethod
    def _defaults(cls, _mapping: AttrMap = None, _format: str = None) -> Dict[str, Any]:
        _format = cls._format if _format is None else _format
        _mapping = cls._mapping if _mapping is None else _mapping
        types = common.split_format(_format)
        assert mapping_length(_mapping) == len(types), "Invalid mapping for format!"
        # TODO: allow default strings (requires a type_defaults function (see below))
        # -- pass down type_defaults _string_mode (warn / trim / fail) ?
        defaults = cls.from_tuple([
            common.type_defaults[t] if not t.endswith("s") else ""
            for t in types],
            _mapping=_mapping, _format=_format)
        return dict(zip(list(_mapping), defaults))

    # convertors
    @classmethod
    def from_bytes(cls, _bytes: bytes, _mapping=None, _format=None,
                   _bitfields=None, _classes=None) -> MappedArray:
        _format = cls._format if _format is None else _format
        _mapping = cls._mapping if _mapping is None else _mapping
        _classes = cls._classes if _classes is None else _classes
        _bitfields = cls._bitfields if _bitfields is None else _bitfields
        assert len(_bytes) == struct.calcsize(_format)
        _tuple = struct.unpack(_format, _bytes)
        assert len(_tuple) == mapping_length(_mapping), f"{_tuple}"
        return cls.from_tuple(_tuple, _mapping=_mapping, _format=_format, _bitfields=_bitfields, _classes=_classes)

    @classmethod
    def from_stream(cls, stream, _mapping=None, _format=None, _bitfields=None, _classes=None) -> MappedArray:
        kwargs = dict(_mapping=_mapping, _format=_format, _bitfields=_bitfields, _classes=_classes)
        return cls.from_bytes(stream.read(struct.calcsize(cls._format)), **kwargs)

    @classmethod
    def from_tuple(cls, array, _mapping=None, _format=None, _bitfields=None, _classes=None) -> MappedArray:
        _format = cls._format if _format is None else _format
        _mapping = cls._mapping if _mapping is None else _mapping
        _classes = cls._classes if _classes is None else _classes
        _bitfields = cls._bitfields if _bitfields is None else _bitfields
        assert len(array) == mapping_length({None: _mapping}), f"{cls.__name__}({array}, _mapping={_mapping})"
        out_args = list()
        if not isinstance(_mapping, (dict, list, int)):
            raise RuntimeError(f"Unexpected mapping: {type(_mapping)}")
        elif isinstance(_mapping, dict):
            types = common.split_format(_format)
            array_index = 0
            for child_mapping in _mapping.values():
                if child_mapping is not None:  # __init__ might make this redundant
                    length = mapping_length({None: child_mapping})
                    segment = array[array_index:array_index + length]
                    child_format = "".join(types[array_index:array_index + length])
                    array_index += mapping_length({None: child_mapping})
                    child = MappedArray.from_tuple(segment, _mapping=child_mapping, _format=child_format)
                    # NOTE: _classes & _bitfields will be passed down in __init__
                else:  # if {"attr": None}
                    child = array[array_index]  # take a single item, not a slice
                    array_index += 1
                out_args.append(child)
        elif isinstance(_mapping, list):  # List[str]
            out_args = array
        # create MappedArray / List
        if not isinstance(_mapping, int):
            out = cls(*out_args, _mapping=_mapping, _format=_format, _bitfields=_bitfields, _classes=_classes)
        # TODO: List[MappedArray]
        else:
            out = list(array)  # LAZY HACK?
        return out

    def as_bytes(self) -> bytes:
        return struct.pack(self._format, *self.as_tuple())

    def as_tuple(self) -> tuple:
        """recreates the array this instance was generated from"""
        _tuple = list()
        for attr in self._mapping:
            value = getattr(self, attr)
            if isinstance(value, MappedArray):
                _tuple.extend(value.as_tuple())  # recursive call
            elif isinstance(value, bitfield.BitField):
                _tuple.append(value.as_int())
            elif isinstance(value, str):
                _tuple.append(value.encode("ascii", errors="ignore"))
            elif isinstance(value, bytes):
                _tuple.append(value)
            elif isinstance(value, (enum.Enum, enum.IntFlag)):  # enum _classes -> int
                _tuple.append(value.value)
            elif isinstance(value, Iterable):  # includes _classes
                _tuple.extend(value)
            else:
                _tuple.append(value)
        return tuple(_tuple)
